function S = read_eyeseecam_log(fn)

matfile = strrep(fn, '.esci', '.mat');
if exist(matfile, 'file')
   load(matfile, 'EyeSeeCamData');
   S = EyeSeeCamData;
   return;
end

info = dir(fn);

npacket = info.bytes / 288;

fp = fopen(fn, 'rb', 'b');

timeStamps = NaN*ones(npacket, 6);
data = NaN*ones(npacket, 56);
hostTime = int64(NaN*ones(npacket, 1));

fprintf('Converting EyeSeeCam data: 00%%');
pctDone = 0;
for k = 1:npacket
   p = round(k/npacket*100);
   if p > pctDone
      pctDone = p;
      fprintf('\b\b\b%02d%%', p);
   end

   nread = fread(fp, 1, 'int32');
   bytes = fread(fp, nread, 'uint8=>uint8');

   hostTime(k) = typecast(flip(bytes(1:8)), 'int64');

   group1 = typecast(flip(bytes(9:12)), 'uint32');
   % RecordingState -- 0:Idle, 1: Prepared, 2: Recording
   RecordingState = bitand(bitshift(group1, -1), 7); %#ok<NASGU>

   bytes_group2 = reshape(bytes(13:60), [8 6]);
   bytes_group2 = flipud(bytes_group2);
   for j = 1:6
      values_group2(j) = double(typecast(bytes_group2(:, j), 'uint64'));  %#ok<AGROW>
   end
   values_group2(1:4) = values_group2(1:4) / 1e9;
   timeStamps(k,:) = values_group2;

   bytes_group3 = reshape(bytes(61:end), [4, 56]);
   bytes_group3 = flipud(bytes_group3);
   for j = 1:56
      values_group3(j) = double(typecast(bytes_group3(:, j), 'single')); %#ok<AGROW> 
   end
   data(k, :) = values_group3;
end

fclose(fp);
fprintf('\n');

% Turns out the clock starts and stops when the Mac software is started and
% stopped during calibration etc. Here we'll try to filter that out
leftTime = timeStamps(:, 1);
istart = find(leftTime == 0, 1, 'last');
if isempty(istart)
   istart = 1;
end
ifilt = istart:length(leftTime);

S = struct(...
   'HostTime', hostTime(ifilt), ...
   'LeftTime', timeStamps(ifilt, 1), ...
   'LeftSystemTime', timeStamps(ifilt, 2), ...
   'RightTime', timeStamps(ifilt, 3), ...
   'RightSystemTime', timeStamps(ifilt, 4), ...
   'LeftFrameCounter', timeStamps(ifilt, 5), ...
   'RightFrameCounter', timeStamps(ifilt, 6) ...
   );

varNames = {...
   'HeadInertialAccelX', ...
   'HeadInertialAccelXCal', ...
   'HeadInertialAccelY', ...
   'HeadInertialAccelYCal', ...
   'HeadInertialAccelZ', ...
   'HeadInertialAccelZCal', ...
   'HeadInertialMagX', ...
   'HeadInertialMagXCal', ...
   'HeadInertialMagY', ...
   'HeadInertialMagYCal', ...
   'HeadInertialMagZ', ...
   'HeadInertialMagZCal', ...
   'HeadInertialPosX', ...
   'HeadInertialPosXCal', ...
   'HeadInertialPosY', ...
   'HeadInertialPosYCal', ...
   'HeadInertialPosZ', ...
   'HeadInertialPosZCal', ...
   'HeadInertialVelX', ...
   'HeadInertialVelXCal', ...
   'HeadInertialVelY', ...
   'HeadInertialVelYCal', ...
   'HeadInertialVelZ', ...
   'HeadInertialVelZCal', ...
   'LeftEyePosX', ...
   'LeftEyePosY', ...
   'LeftEyePosZ', ...
   'LeftEyeVelX', ...
   'LeftEyeVelY', ...
   'LeftEyeVelZ', ...
   'LeftPupilCol', ...
   'LeftPupilCovXX', ...
   'LeftPupilCovXY', ...
   'LeftPupilCovYY', ...
   'LeftPupilMethod', ...
   'LeftPupilRow', ...
   'LeftReflexCenterX', ...
   'LeftReflexCenterY', ...
   'RightEyePosX', ...
   'RightEyePosY', ...
   'RightEyePosZ', ...
   'RightEyeVelX', ...
   'RightEyeVelY', ...
   'RightEyeVelZ', ...
   'RightPupilCol', ...
   'RightPupilCovXX', ...
   'RightPupilCovXY', ...
   'RightPupilCovYY', ...
   'RightPupilMethod', ...
   'RightPupilRow', ...
   'RightReflexCenterX', ...
   'RightReflexCenterY', ...
   'TargetHor', ...
   'TargetVer', ...
   'visual_pos3', ...
   'visual_pos4' ...
   };

for k = 1:length(varNames)
   S.(varNames{k}) = data(ifilt, k);
end

syncLogFile = strrep(fn, '.esci', '.sync');
if exist(syncLogFile, 'file')
   eyeSeeCamSyncLog = jenks.read_eyeseecam_sync_log([fnEyeSeeCam '.sync']);
   S.tsync = eyeSeeCamSyncLog.Tsync;
end

EyeSeeCamData = S;
save(matfile, 'EyeSeeCamData');